<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Hydrogen Atom – Quantum Energy Levels</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
}

body {
  background: #000010;
  color: #c8d8ff;
  font-family: 'Courier New', monospace;
  display: flex;
  flex-direction: column;
  touch-action: none;
}

/* ══════════════════════════════════════════════════════════════════ */
/* RESPONSIVE LAYOUT */
/* ══════════════════════════════════════════════════════════════════ */

#app {
  flex: 1;
  display: flex;
  flex-direction: row;
  overflow: hidden;
}

/* Desktop: sidebar + main */
@media (min-width: 1024px) {
  #sidebar {
    width: 290px;
    min-width: 290px;
    flex-shrink: 0;
    border-right: 1px solid rgba(60, 100, 255, 0.25);
  }

  #main {
    flex: 1;
  }

  #menu-toggle {
    display: none !important;
  }
}

/* Tablet: narrower sidebar or collapsible */
@media (min-width: 768px) and (max-width: 1023px) {
  #sidebar {
    width: 220px;
    min-width: 220px;
    flex-shrink: 0;
    border-right: 1px solid rgba(60, 100, 255, 0.25);
  }

  #main {
    flex: 1;
  }

  #menu-toggle {
    display: none !important;
  }
}

/* Mobile: full-screen canvas with floating control panel */
@media (max-width: 767px) {
  #app {
    flex-direction: column;
  }

  #main {
    flex: 1;
    width: 100%;
  }

  #sidebar {
    position: fixed;
    top: 0;
    left: -100%;
    width: 100%;
    max-width: 300px;
    height: 100%;
    background: rgba(0, 4, 22, 0.98);
    border-right: 1px solid rgba(60, 100, 255, 0.25);
    transition: left 0.3s ease;
    z-index: 100;
    overflow-y: auto;
    padding-bottom: 20px;
  }

  #sidebar.open {
    left: 0;
  }

  #menu-toggle {
    display: flex !important;
    position: fixed;
    top: 12px;
    left: 12px;
    width: 44px;
    height: 44px;
    background: rgba(0, 4, 22, 0.9);
    border: 1px solid rgba(60, 100, 255, 0.3);
    border-radius: 8px;
    z-index: 101;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    flex-direction: column;
    gap: 4px;
    padding: 0;
  }

  .hamburger-line {
    width: 18px;
    height: 2px;
    background: #4a7aff;
    border-radius: 1px;
    transition: all 0.3s;
  }

  #sidebar.open ~ #menu-toggle .hamburger-line:nth-child(1) {
    transform: rotate(45deg) translate(8px, 8px);
  }

  #sidebar.open ~ #menu-toggle .hamburger-line:nth-child(2) {
    opacity: 0;
  }

  #sidebar.open ~ #menu-toggle .hamburger-line:nth-child(3) {
    transform: rotate(-45deg) translate(7px, -7px);
  }

  #canvas-wrap {
    width: 100%;
    height: 100%;
  }

  #controls-hint {
    bottom: 8px !important;
    right: 8px !important;
    font-size: 9px !important;
    padding: 6px 10px !important;
  }
}

/* ══════════════════════════════════════════════════════════════════ */
/* SIDEBAR STYLES */
/* ══════════════════════════════════════════════════════════════════ */

#sidebar {
  background: rgba(0, 4, 22, 0.92);
  display: flex;
  flex-direction: column;
  padding: 16px;
  gap: 14px;
  overflow-y: auto;
}

#sidebar h1 {
  font-size: 11px;
  font-weight: normal;
  color: #3a6aff;
  text-transform: uppercase;
  letter-spacing: 3px;
  text-align: center;
  padding-bottom: 10px;
  border-bottom: 1px solid rgba(60, 100, 255, 0.2);
}

.section-label {
  font-size: 9px;
  color: #2a4a99;
  text-transform: uppercase;
  letter-spacing: 2px;
  margin-bottom: 4px;
}

/* Energy diagram */
#energy-wrap {
  flex: 1;
  min-height: 140px;
  position: relative;
}

#energy-canvas {
  width: 100%;
  height: 100%;
  cursor: pointer;
  border-radius: 4px;
  -webkit-user-select: none;
  user-select: none;
}

/* State info */
#state-card {
  background: rgba(6, 14, 55, 0.8);
  border: 1px solid rgba(60, 100, 255, 0.2);
  border-radius: 8px;
  padding: 12px;
}

#orbital-badge {
  font-size: 26px;
  font-weight: bold;
  color: #a0c4ff;
  text-align: center;
  line-height: 1;
  margin-bottom: 4px;
  letter-spacing: 2px;
}

@media (max-width: 767px) {
  #orbital-badge { font-size: 20px; }
}

#energy-display {
  font-size: 11px;
  color: #4a6aaa;
  text-align: center;
  margin-bottom: 10px;
}

.qn-row {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  margin-bottom: 5px;
}

.qn-label { color: #4a5a88; }
.qn-val   { color: #60aaff; font-weight: bold; }

/* Sliders & Controls */
.ctrl-block {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.ctrl-row {
  display: flex;
  flex-direction: column;
  gap: 3px;
}

.ctrl-label {
  font-size: 10px;
  color: #3a5080;
  display: flex;
  justify-content: space-between;
}

.ctrl-label span { color: #50aaff; }

input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 4px;
  background: rgba(40, 80, 200, 0.3);
  border-radius: 2px;
  outline: none;
  cursor: pointer;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: #3a7aff;
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 6px rgba(58, 122, 255, 0.6);
}

input[type="range"]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: #3a7aff;
  border-radius: 50%;
  cursor: pointer;
  box-shadow: 0 0 6px rgba(58, 122, 255, 0.6);
  border: none;
}

@media (max-width: 767px) {
  input[type="range"] {
    height: 5px;
  }

  input[type="range"]::-webkit-slider-thumb {
    width: 20px;
    height: 20px;
  }
}

/* Quick-select buttons */
.quick-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 5px;
}

@media (min-width: 768px) {
  .quick-grid {
    grid-template-columns: repeat(4, 1fr);
    gap: 4px;
  }
}

.qbtn {
  background: rgba(20, 40, 120, 0.4);
  border: 1px solid rgba(60, 100, 200, 0.25);
  color: #6080c0;
  font-family: inherit;
  font-size: 10px;
  padding: 6px 0;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.15s;
  text-align: center;
  -webkit-user-select: none;
  user-select: none;
  touch-action: manipulation;
}

.qbtn:hover, .qbtn:active {
  background: rgba(40, 80, 200, 0.4);
  color: #a0c0ff;
}

.qbtn.active {
  background: rgba(60, 120, 255, 0.3);
  border-color: rgba(100, 160, 255, 0.5);
  color: #c0d8ff;
}

@media (max-width: 767px) {
  .qbtn { padding: 8px 0; }
}

/* Keyboard hint */
#kbd-hint {
  font-size: 9px;
  color: #202e5a;
  text-align: center;
  line-height: 1.6;
}

/* ══════════════════════════════════════════════════════════════════ */
/* MAIN VIEW */
/* ══════════════════════════════════════════════════════════════════ */

#main {
  position: relative;
  overflow: hidden;
}

#canvas-wrap {
  width: 100%;
  height: 100%;
  touch-action: none;
}

canvas {
  display: block;
  touch-action: none;
}

/* Overlays */
#loading-overlay {
  position: absolute;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 12, 0.5);
  z-index: 20;
  pointer-events: none;
}

#loading-text {
  font-size: 13px;
  color: #4070cc;
  letter-spacing: 3px;
  animation: pulse 1s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 0.4; }
  50% { opacity: 1; }
}

#photon-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s;
  z-index: 15;
}

#photon-lambda {
  font-size: 22px;
  font-weight: bold;
  text-shadow: 0 0 12px currentColor;
}

#photon-info {
  font-size: 11px;
  color: #6080a0;
  margin-top: 3px;
}

#controls-hint {
  position: absolute;
  bottom: 16px;
  right: 16px;
  background: rgba(0, 5, 24, 0.7);
  border: 1px solid rgba(40, 70, 180, 0.2);
  border-radius: 6px;
  padding: 8px 12px;
  font-size: 10px;
  color: #304070;
  line-height: 1.8;
  pointer-events: none;
  -webkit-user-select: none;
  user-select: none;
}

@media (max-width: 767px) {
  #controls-hint {
    display: block;
    bottom: 60px;
    right: 8px;
    font-size: 9px;
    padding: 6px 10px;
  }

  .desktop-hint { display: none !important; }
  .mobile-hint { display: inline !important; }
}

#state-hint {
  position: absolute;
  top: 16px;
  left: 16px;
  font-size: 11px;
  color: #2a4070;
  pointer-events: none;
  letter-spacing: 1px;
}

@media (max-width: 767px) {
  #state-hint {
    top: 62px;
  }
}

#menu-toggle {
  display: none;
}

/* Close sidebar when clicking outside on mobile */
@media (max-width: 767px) {
  body.sidebar-open {
    overflow: hidden;
  }

  #sidebar.open::before {
    content: '';
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.4);
    z-index: -1;
    pointer-events: none;
  }
}
</style>
</head>
<body>

<div id="app">
  <!-- ════ SIDEBAR ════ -->
  <aside id="sidebar">
    <h1>Hydrogen Atom</h1>

    <div>
      <div class="section-label">Energy Levels (click to jump)</div>
      <div id="energy-wrap">
        <canvas id="energy-canvas"></canvas>
      </div>
    </div>

    <div id="state-card">
      <div id="orbital-badge">1s</div>
      <div id="energy-display">E = −13.6000 eV</div>
      <div class="qn-row"><span class="qn-label">n</span><span class="qn-val" id="n-val">1</span></div>
      <div class="qn-row"><span class="qn-label">ℓ</span><span class="qn-val" id="l-val">0</span></div>
      <div class="qn-row"><span class="qn-label">m</span><span class="qn-val" id="m-val">0</span></div>
    </div>

    <div class="ctrl-block">
      <div class="section-label">Quantum Numbers</div>

      <div class="ctrl-row">
        <div class="ctrl-label">n <span id="n-label">1</span></div>
        <input type="range" id="n-slider" min="1" max="6" value="1">
      </div>

      <div class="ctrl-row">
        <div class="ctrl-label">ℓ <span id="l-label">0</span></div>
        <input type="range" id="l-slider" min="0" max="0" value="0">
      </div>

      <div class="ctrl-row">
        <div class="ctrl-label">m <span id="m-label">0</span></div>
        <input type="range" id="m-slider" min="0" max="0" value="0">
      </div>
    </div>

    <div>
      <div class="section-label" style="margin-bottom: 6px">Quick Select</div>
      <div class="quick-grid" id="quick-grid">
        <button class="qbtn active" data-state="1,0,0">1s</button>
        <button class="qbtn" data-state="2,0,0">2s</button>
        <button class="qbtn" data-state="2,1,0">2p₀</button>
        <button class="qbtn" data-state="3,0,0">3s</button>
        <button class="qbtn" data-state="3,1,0">3p₀</button>
        <button class="qbtn" data-state="3,2,0">3d₀</button>
        <button class="qbtn" data-state="4,0,0">4s</button>
        <button class="qbtn" data-state="4,3,0">4f₀</button>
        <button class="qbtn" data-state="5,4,0">5g₀</button>
        <button class="qbtn" data-state="6,5,0">6h₀</button>
        <button class="qbtn" data-state="2,1,1">2p</button>
        <button class="qbtn" data-state="3,2,2">3d</button>
      </div>
    </div>

    <div id="kbd-hint">
      ↑↓ change n · ←→ change ℓ<br>
      Shift+←→ change m
    </div>
  </aside>

  <!-- ════ MAIN VIEW ════ -->
  <main id="main">
    <div id="canvas-wrap"></div>

    <div id="loading-overlay">
      <div id="loading-text">COMPUTING ORBITAL…</div>
    </div>

    <div id="photon-overlay">
      <div id="photon-lambda"></div>
      <div id="photon-info"></div>
    </div>

    <div id="controls-hint">
      <span class="desktop-hint">Drag · Rotate · Scroll · Zoom<br>Right-drag · Pan</span>
      <span class="mobile-hint" style="display: none;">Drag to rotate<br>2-finger pinch to zoom</span>
    </div>

    <div id="state-hint"></div>
  </main>

  <!-- Mobile menu toggle -->
  <button id="menu-toggle" aria-label="Toggle menu">
    <div class="hamburger-line"></div>
    <div class="hamburger-line"></div>
    <div class="hamburger-line"></div>
  </button>
</div>

<!-- ════ IMPORTMAP ════ -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ═══════════════════════════════════════════════════════════════
// QUANTUM MECHANICS MATH
// ═══════════════════════════════════════════════════════════════

function factorial(n) {
  if (n <= 1) return 1;
  let f = 1;
  for (let i = 2; i <= n; i++) f *= i;
  return f;
}

function assocLaguerre(p, alpha, x) {
  if (p === 0) return 1;
  if (p === 1) return 1 + alpha - x;
  let L0 = 1, L1 = 1 + alpha - x;
  for (let k = 2; k <= p; k++) {
    const L2 = ((2*k - 1 + alpha - x) * L1 - (k - 1 + alpha) * L0) / k;
    L0 = L1; L1 = L2;
  }
  return L1;
}

function assocLegendre(l, m, x) {
  let Pmm = 1;
  const sq = Math.sqrt(Math.max(0, 1 - x*x));
  for (let i = 1; i <= m; i++) Pmm *= -(2*i - 1) * sq;
  if (l === m) return Pmm;
  let P0 = Pmm, P1 = (2*m + 1) * x * Pmm;
  if (l === m + 1) return P1;
  for (let j = m + 2; j <= l; j++) {
    const P2 = ((2*j - 1) * x * P1 - (j + m - 1) * P0) / (j - m);
    P0 = P1; P1 = P2;
  }
  return P1;
}

function radialWF(n, l, r) {
  if (r < 1e-10) r = 1e-10;
  const rho = 2 * r / n;
  const norm = Math.sqrt(Math.pow(2 / n, 3) * factorial(n - l - 1) / (2 * n * factorial(n + l)));
  return norm * Math.exp(-r / n) * Math.pow(rho, l) * assocLaguerre(n - l - 1, 2*l + 1, rho);
}

function spherHarm(l, m, theta, phi) {
  const am = Math.abs(m);
  const P = assocLegendre(l, am, Math.cos(theta));
  const norm = Math.sqrt((2*l + 1) / (4 * Math.PI) * factorial(l - am) / factorial(l + am));
  if (m > 0) return Math.SQRT2 * norm * P * Math.cos(m * phi);
  if (m < 0) return Math.SQRT2 * norm * P * Math.sin(am * phi);
  return norm * P;
}

function psi2(n, l, m, x, y, z) {
  const r = Math.sqrt(x*x + y*y + z*z);
  if (r < 1e-10) return 0;
  const theta = Math.acos(Math.max(-1, Math.min(1, z / r)));
  const phi = Math.atan2(y, x);
  const R = radialWF(n, l, r);
  const Y = spherHarm(l, m, theta, phi);
  return R * R * Y * Y;
}

const energyEV = n => -13.6 / (n * n);
const ORBITAL_LABELS = ['s', 'p', 'd', 'f', 'g', 'h'];
function orbitalName(n, l) { return `${n}${ORBITAL_LABELS[l] ?? '?'}`; }

// ═══════════════════════════════════════════════════════════════
// SAMPLING
// ═══════════════════════════════════════════════════════════════

function buildRadialCDF(n, l) {
  const N = 1200, rMax = Math.max(7 * n * n, 18), dr = rMax / N;
  const pdf = new Float64Array(N);
  let total = 0;
  for (let i = 0; i < N; i++) {
    const r = (i + 0.5) * dr;
    const R = radialWF(n, l, r);
    pdf[i] = r * r * R * R * dr;
    total += pdf[i];
  }
  const cdf = new Float64Array(N);
  cdf[0] = pdf[0] / total;
  for (let i = 1; i < N; i++) cdf[i] = cdf[i-1] + pdf[i] / total;
  return { cdf, rMax, dr, N };
}

function sampleR({ cdf, dr }) {
  const u = Math.random();
  let lo = 0, hi = cdf.length - 1;
  while (lo < hi) {
    const mid = (lo + hi) >> 1;
    if (cdf[mid] < u) lo = mid + 1; else hi = mid;
  }
  return (lo + Math.random()) * dr;
}

function maxY2(l, m) {
  let mx = 0;
  const N = 80;
  for (let i = 0; i <= N; i++) {
    const theta = Math.PI * i / N;
    for (let j = 0; j <= N; j++) {
      const phi = 2 * Math.PI * j / N;
      const v = spherHarm(l, m, theta, phi);
      if (v * v > mx) mx = v * v;
    }
  }
  return mx || 1e-10;
}

// ═══════════════════════════════════════════════════════════════
// THREE.JS SETUP
// ═══════════════════════════════════════════════════════════════

const container = document.getElementById('canvas-wrap');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000008);

const camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 0.01, 50000);
camera.position.set(0, 0, 28);

const orbitCtrl = new OrbitControls(camera, renderer.domElement);
orbitCtrl.enableDamping = true;
orbitCtrl.dampingFactor = 0.06;
orbitCtrl.minDistance = 0.5;
orbitCtrl.maxDistance = 20000;
orbitCtrl.enableZoom = true;
orbitCtrl.enableRotate = true;
orbitCtrl.enablePan = true;

// ── Mobile touch: own spherical-coord rotation + pinch zoom ──────────
// OrbitControls handles mouse; this handles touch independently.
let touchRotate = null;
let touchZoomDist = 0;

renderer.domElement.addEventListener('touchstart', (e) => {
  orbitCtrl.enabled = false; // park OrbitControls while finger is down
  if (e.touches.length === 1) {
    const r   = camera.position.length();
    const phi = Math.acos(Math.max(-1, Math.min(1, camera.position.y / r)));
    touchRotate = {
      x: e.touches[0].clientX,
      y: e.touches[0].clientY,
      theta: Math.atan2(camera.position.x, camera.position.z),
      phi,
    };
    touchZoomDist = 0;
  } else if (e.touches.length === 2) {
    touchRotate = null;
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    touchZoomDist = Math.sqrt(dx * dx + dy * dy);
  }
}, false);

renderer.domElement.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (e.touches.length === 1 && touchRotate) {
    const dx = e.touches[0].clientX - touchRotate.x;
    const dy = e.touches[0].clientY - touchRotate.y;
    touchRotate.x = e.touches[0].clientX;
    touchRotate.y = e.touches[0].clientY;
    touchRotate.theta -= dx * 0.008;
    touchRotate.phi = Math.max(0.05, Math.min(Math.PI - 0.05, touchRotate.phi + dy * 0.008));
    const r = camera.position.length();
    camera.position.set(
      r * Math.sin(touchRotate.phi) * Math.sin(touchRotate.theta),
      r * Math.cos(touchRotate.phi),
      r * Math.sin(touchRotate.phi) * Math.cos(touchRotate.theta)
    );
    camera.lookAt(0, 0, 0);
  } else if (e.touches.length === 2 && touchZoomDist > 0) {
    const dx   = e.touches[0].clientX - e.touches[1].clientX;
    const dy   = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    camTargetDist = Math.max(0.5, Math.min(20000, camTargetDist * (touchZoomDist / dist)));
    touchZoomDist = dist;
  }
}, { passive: false });

renderer.domElement.addEventListener('touchend', (e) => {
  if (e.touches.length === 0) {
    touchRotate   = null;
    touchZoomDist = 0;
    orbitCtrl.enabled = true; // give control back to mouse
  } else if (e.touches.length === 1) {
    touchZoomDist = 0;
    const r   = camera.position.length();
    const phi = Math.acos(Math.max(-1, Math.min(1, camera.position.y / r)));
    touchRotate = {
      x: e.touches[0].clientX,
      y: e.touches[0].clientY,
      theta: Math.atan2(camera.position.x, camera.position.z),
      phi,
    };
  }
}, false);
// ─────────────────────────────────────────────────────────────────────

// Star field
const starGeo = new THREE.BufferGeometry();
const starPos = new Float32Array(4000 * 3);
for (let i = 0; i < 4000; i++) {
  starPos[i*3] = (Math.random() - 0.5) * 4000;
  starPos[i*3+1] = (Math.random() - 0.5) * 4000;
  starPos[i*3+2] = (Math.random() - 0.5) * 4000;
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.6, transparent: true, opacity: 0.35 })));

// Nucleus
const nucleusMesh = new THREE.Mesh(new THREE.SphereGeometry(0.6, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffcc44 }));
scene.add(nucleusMesh);

const haloMesh = new THREE.Mesh(new THREE.SphereGeometry(1.4, 32, 32), new THREE.MeshBasicMaterial({ color: 0xff8800, transparent: true, opacity: 0.18, blending: THREE.AdditiveBlending, depthWrite: false }));
scene.add(haloMesh);

// Axes
const axesMat = (hex) => new THREE.LineBasicMaterial({ color: hex, transparent: true, opacity: 0.12 });
function addAxis(dir, mat) {
  const pts = [new THREE.Vector3(), dir];
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), mat));
}
addAxis(new THREE.Vector3(200, 0, 0), axesMat(0xff2222));
addAxis(new THREE.Vector3(0, 200, 0), axesMat(0x22ff22));
addAxis(new THREE.Vector3(0, 0, 200), axesMat(0x2222ff));

// ═══════════════════════════════════════════════════════════════
// ORBITAL CLOUD
// ═══════════════════════════════════════════════════════════════

const NUM_PTS = 12000;
const LEVEL_COLORS = [
  new THREE.Color(0.28, 0.58, 1.00),
  new THREE.Color(0.00, 0.85, 1.00),
  new THREE.Color(0.20, 1.00, 0.55),
  new THREE.Color(0.85, 1.00, 0.10),
  new THREE.Color(1.00, 0.55, 0.08),
  new THREE.Color(1.00, 0.20, 0.40),
];

let cloudOld = null, cloudNew = null, transT = 1.0;
const TRANS_DUR = 0.6;

function getColor(n) { return LEVEL_COLORS[Math.min(n - 1, 5)]; }

function buildCloud(n, l, m) {
  const cdfData = buildRadialCDF(n, l);
  const mY2 = maxY2(l, m);
  const base = getColor(n);
  const posArr = new Float32Array(NUM_PTS * 3);
  const colArr = new Float32Array(NUM_PTS * 3);
  let i = 0, guard = NUM_PTS * 120;
  while (i < NUM_PTS && --guard > 0) {
    const r = sampleR(cdfData);
    const cosT = 2 * Math.random() - 1;
    const sinT = Math.sqrt(Math.max(0, 1 - cosT * cosT));
    const phi = 2 * Math.PI * Math.random();
    const Y = spherHarm(l, m, Math.acos(cosT), phi);
    const y2 = Y * Y;
    if (Math.random() * mY2 > y2) continue;
    const x = r * sinT * Math.cos(phi);
    const y = r * sinT * Math.sin(phi);
    const z = r * cosT;
    posArr[i*3] = x; posArr[i*3+1] = y; posArr[i*3+2] = z;
    const t = Math.pow(y2 / mY2, 0.35);
    colArr[i*3] = base.r * 0.5 + 0.5 * t;
    colArr[i*3+1] = base.g * 0.5 + 0.5 * t;
    colArr[i*3+2] = base.b * 0.5 + 0.5 * t;
    i++;
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
  const mat = new THREE.PointsMaterial({
    size: 0.35 * Math.max(1, n * 0.7),
    vertexColors: true, transparent: true, opacity: 0,
    blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true,
  });
  return new THREE.Points(geo, mat);
}

function animateCameraTo(n) {
  camTargetDist = Math.max(22, 3.2 * n * n);
}

let camTargetDist = 28;

// ═══════════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════════

let state = { n: 1, l: 0, m: 0 };

function loadingVisible(v) {
  document.getElementById('loading-overlay').style.display = v ? 'flex' : 'none';
}

function setState(n, l, m, skipPhoton = false) {
  if (!skipPhoton) {
    const dE = Math.abs(energyEV(n) - energyEV(state.n));
    if (dE > 0.01) showPhoton(dE, energyEV(n) < energyEV(state.n));
  }
  state = { n, l, m };
  updateUI();
  closeSidebar();
  loadingVisible(true);
  setTimeout(() => {
    if (cloudNew) {
      if (cloudOld) { scene.remove(cloudOld); cloudOld.geometry.dispose(); cloudOld.material.dispose(); }
      cloudOld = cloudNew;
      cloudOld.material.opacity = 0.8;
    }
    cloudNew = buildCloud(n, l, m);
    cloudNew.material.opacity = 0;
    scene.add(cloudNew);
    transT = 0;
    animateCameraTo(n);
    loadingVisible(false);
  }, 30);
}

function updateUI() {
  const { n, l, m } = state;
  const E = energyEV(n);
  const name = orbitalName(n, l);
  const mStr = m === 0 ? '' : (m > 0 ? `⁺${m}` : `${m}`);

  document.getElementById('orbital-badge').textContent = name + mStr;
  document.getElementById('energy-display').textContent = `E = ${E.toFixed(4)} eV`;
  document.getElementById('n-val').textContent = n;
  document.getElementById('l-val').textContent = l;
  document.getElementById('m-val').textContent = m;

  document.getElementById('n-slider').value = n;
  const lSlider = document.getElementById('l-slider');
  lSlider.max = n - 1; lSlider.value = l;
  const mSlider = document.getElementById('m-slider');
  mSlider.min = -l; mSlider.max = l; mSlider.value = m;

  document.getElementById('n-label').textContent = n;
  document.getElementById('l-label').textContent = l;
  document.getElementById('m-label').textContent = m;

  const key = `${n},${l},${m}`;
  document.querySelectorAll('.qbtn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.state === key);
  });

  drawEnergyDiagram();
}

let photonTimer = null;

function showPhoton(deltaE, isEmission) {
  const lambda = 1240 / deltaE;
  let color, region;
  if      (lambda < 10)  { color = '#ffffff'; region = 'X-ray'; }
  else if (lambda < 100) { color = '#cc44ff'; region = 'EUV'; }
  else if (lambda < 380) { color = '#7766ff'; region = 'UV'; }
  else if (lambda < 450) { color = '#4466ff'; region = 'Violet'; }
  else if (lambda < 495) { color = '#2288ff'; region = 'Blue'; }
  else if (lambda < 570) { color = '#22ee44'; region = 'Green'; }
  else if (lambda < 590) { color = '#ffff22'; region = 'Yellow'; }
  else if (lambda < 620) { color = '#ffaa22'; region = 'Orange'; }
  else if (lambda < 750) { color = '#ff4422'; region = 'Red'; }
  else                   { color = '#aa2222'; region = 'Infrared'; }

  const el = document.getElementById('photon-overlay');
  const lEl = document.getElementById('photon-lambda');
  const iEl = document.getElementById('photon-info');

  lEl.style.color = color;
  lEl.textContent = `λ = ${lambda.toFixed(1)} nm`;
  iEl.textContent = `${region} · ${isEmission ? 'Emission ↓' : 'Absorption ↑'}`;
  el.style.opacity = '1';
  if (photonTimer) clearTimeout(photonTimer);
  photonTimer = setTimeout(() => { el.style.opacity = '0'; }, 2200);
}

// ═══════════════════════════════════════════════════════════════
// ENERGY DIAGRAM
// ═══════════════════════════════════════════════════════════════

const eCvs = document.getElementById('energy-canvas');
const eCtx = eCvs.getContext('2d');

function sizeEnergyCanvas() {
  const wrap = document.getElementById('energy-wrap');
  eCvs.width = wrap.clientWidth;
  eCvs.height = wrap.clientHeight;
  drawEnergyDiagram();
}

function drawEnergyDiagram() {
  const W = eCvs.width, H = eCvs.height;
  eCtx.clearRect(0, 0, W, H);
  const E_min = -13.6, E_max = 0;
  const pad = { t: 18, b: 22, l: 44, r: 8 };
  const cH = H - pad.t - pad.b;
  const yFor = E => pad.t + cH * (1 - (E - E_min) / (E_max - E_min));

  eCtx.strokeStyle = 'rgba(40,70,180,0.35)';
  eCtx.lineWidth = 1;
  eCtx.beginPath();
  eCtx.moveTo(pad.l, pad.t);
  eCtx.lineTo(pad.l, H - pad.b);
  eCtx.stroke();

  eCtx.setLineDash([3, 5]);
  eCtx.strokeStyle = 'rgba(80,120,255,0.18)';
  eCtx.beginPath();
  eCtx.moveTo(pad.l, pad.t);
  eCtx.lineTo(W - pad.r, pad.t);
  eCtx.stroke();
  eCtx.setLineDash([]);

  eCtx.fillStyle = 'rgba(40,60,140,0.8)';
  eCtx.font = '8px Courier New';
  eCtx.textAlign = 'right';
  eCtx.fillText('0 eV', pad.l - 2, pad.t + 4);
  eCtx.fillText('−13.6', pad.l - 2, H - pad.b + 4);

  eCtx.fillStyle = 'rgba(60,90,180,0.5)';
  eCtx.font = '8px Courier New';
  eCtx.textAlign = 'center';
  eCtx.fillText('ionized', (pad.l + W - pad.r) / 2, pad.t - 4);

  const colors = ['#5090ff','#00d8ff','#30ff90','#c8ff10','#ff8030','#ff2050'];
  for (let n = 1; n <= 6; n++) {
    const E = energyEV(n);
    const y = yFor(E);
    const active = n === state.n;
    const col = colors[n - 1];

    eCtx.strokeStyle = active ? col : col + '66';
    eCtx.lineWidth = active ? 2.5 : 1.2;
    eCtx.beginPath();
    eCtx.moveTo(pad.l + 4, y);
    eCtx.lineTo(W - pad.r, y);
    eCtx.stroke();

    eCtx.fillStyle = active ? col : col + '88';
    eCtx.font = active ? 'bold 10px Courier New' : '9px Courier New';
    eCtx.textAlign = 'left';
    eCtx.fillText(`n=${n}`, pad.l + 7, y - 2);

    eCtx.fillStyle = active ? col + 'cc' : col + '44';
    eCtx.font = '8px Courier New';
    eCtx.textAlign = 'right';
    eCtx.fillText(`${E.toFixed(2)}`, W - pad.r, y - 2);

    if (active) {
      eCtx.fillStyle = col;
      eCtx.beginPath();
      eCtx.arc(pad.l + 2, y, 3, 0, Math.PI * 2);
      eCtx.fill();
    }
  }
}

eCvs.addEventListener('click', (e) => {
  const rect = eCvs.getBoundingClientRect();
  const ry = (e.clientY - rect.top) * (eCvs.height / rect.height);
  const E_min = -13.6, E_max = 0;
  const pad = { t: 18, b: 22 };
  const cH = eCvs.height - pad.t - pad.b;
  const yFor = E => pad.t + cH * (1 - (E - E_min) / (E_max - E_min));

  let best = 1, bestD = Infinity;
  for (let n = 1; n <= 6; n++) {
    const d = Math.abs(ry - yFor(energyEV(n)));
    if (d < bestD) { bestD = d; best = n; }
  }
  if (bestD < 22) {
    const n = best;
    const l = Math.min(state.l, n - 1);
    const m = Math.max(-l, Math.min(l, state.m));
    setState(n, l, m);
  }
});

// ═══════════════════════════════════════════════════════════════
// CONTROLS
// ═══════════════════════════════════════════════════════════════

document.getElementById('n-slider').addEventListener('input', e => {
  const n = +e.target.value;
  const l = Math.min(state.l, n - 1);
  const m = Math.max(-l, Math.min(l, state.m));
  setState(n, l, m);
});

document.getElementById('l-slider').addEventListener('input', e => {
  const l = +e.target.value;
  const m = Math.max(-l, Math.min(l, state.m));
  setState(state.n, l, m);
});

document.getElementById('m-slider').addEventListener('input', e => {
  setState(state.n, state.l, +e.target.value);
});

document.querySelectorAll('.qbtn').forEach(btn => {
  btn.addEventListener('click', () => {
    const [n, l, m] = btn.dataset.state.split(',').map(Number);
    setState(n, l, m);
  });
});

// Mobile sidebar toggle
function closeSidebar() {
  document.getElementById('sidebar').classList.remove('open');
  document.body.classList.remove('sidebar-open');
}

document.getElementById('menu-toggle')?.addEventListener('click', () => {
  const sidebar = document.getElementById('sidebar');
  sidebar.classList.toggle('open');
  document.body.classList.toggle('sidebar-open');
});

// Close sidebar when clicking elsewhere on mobile
if (window.innerWidth <= 767) {
  document.getElementById('main').addEventListener('click', closeSidebar);
}

document.addEventListener('keydown', e => {
  let { n, l, m } = state;
  switch (e.code) {
    case 'ArrowUp': n = Math.min(6, n + 1); l = Math.min(l, n-1); m = Math.max(-l, Math.min(l, m)); break;
    case 'ArrowDown': n = Math.max(1, n - 1); l = Math.min(l, n-1); m = Math.max(-l, Math.min(l, m)); break;
    case 'ArrowRight': if (e.shiftKey) m = Math.min(l, m+1); else l = Math.min(n-1, l+1); m = Math.max(-l, Math.min(l,m)); break;
    case 'ArrowLeft': if (e.shiftKey) m = Math.max(-l, m-1); else l = Math.max(0, l-1); m = Math.max(-l, Math.min(l,m)); break;
    default: return;
  }
  e.preventDefault();
  setState(n, l, m);
});

// ═══════════════════════════════════════════════════════════════
// ANIMATION
// ═══════════════════════════════════════════════════════════════

let lastTime = performance.now();

function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 0.1);
  lastTime = now;

  if (transT < 1) {
    transT = Math.min(1, transT + dt / TRANS_DUR);
    const t = transT * transT * (3 - 2 * transT);
    if (cloudOld) {
      cloudOld.material.opacity = 0.8 * (1 - t);
      if (transT >= 1) {
        scene.remove(cloudOld);
        cloudOld.geometry.dispose();
        cloudOld.material.dispose();
        cloudOld = null;
      }
    }
    if (cloudNew) cloudNew.material.opacity = 0.8 * t;
  }

  const curDist = camera.position.length();
  if (Math.abs(curDist - camTargetDist) > 0.1) {
    const nd = curDist + (camTargetDist - curDist) * Math.min(1, dt * 2.5);
    camera.position.setLength(nd);
  }

  const pulse = 1 + 0.06 * Math.sin(now * 0.003);
  nucleusMesh.scale.setScalar(pulse);
  haloMesh.scale.setScalar(pulse * 1.1);

  if (cloudNew) cloudNew.rotation.y += dt * 0.18;
  if (cloudOld) cloudOld.rotation.y += dt * 0.18;

  orbitCtrl.update();
  renderer.render(scene, camera);
}

// ═══════════════════════════════════════════════════════════════
// RESIZE
// ═══════════════════════════════════════════════════════════════

const resizeObs = new ResizeObserver(() => {
  const w = container.clientWidth, h = container.clientHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  sizeEnergyCanvas();
});
resizeObs.observe(container);

window.addEventListener('resize', sizeEnergyCanvas);

// ═══════════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════════

sizeEnergyCanvas();
setState(1, 0, 0, true);
animate();
</script>
</body>
</html>
